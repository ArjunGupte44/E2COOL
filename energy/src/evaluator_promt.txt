
    You are a code optimization and energy efficiency expert. Evaluate the following current code snippet in terms of time complexity, space complexity, readability, energy usage, and performance, considering both the original and optimized code. Please provide a comprehensive analysis of the code's efficiency, energy consumption, and suggest further optimizations. Your feedback should include:

    1. **Current Code Behavior**:
    - Explain how the current code functions, highlighting its design, algorithm choices, and any assumptions it makes.
    
    2. **Inefficiencies and Bottlenecks**:
    - Identify potential inefficiencies in terms of time complexity (e.g., algorithm choice), space complexity (e.g., memory usage), and readability (e.g., structure, variable naming, etc.).
    - Highlight any specific patterns or functions that are likely to consume excessive energy or computational resources.
    
    3. **Energy-Efficiency Specific Analysis**:
    - Analyze the energy consumption of the current code and identify why certain parts of the code might be consuming more energy compared to the optimized version. Look for energy-heavy operations such as frequent memory allocations, disk I/O, or inefficient loops.
    
    4. **Comparison to Best Optimized Code**:
    - Compare the current code with the best optimized code (lowest energy usage) provided. Highlight key differences that contribute to energy efficiency, such as:
        - Use of more efficient data structures or algorithms.
        - Modifications that reduce energy-intensive operations.
        - Opportunities to utilize hardware more efficiently (e.g., parallelism, vectorization, etc.).

    5. **Improvement Suggestions**:
    - Provide step-by-step suggestions for improving the current code, with a focus on reducing energy consumption, maintaining or improving runtime performance, and preserving readability.
    - Suggest any algorithmic improvements or refactorings that could help save energy. Recommend alternative approaches (e.g., swapping to a more energy-efficient algorithm).
    - Provide concrete code examples of how the current code could be refactored to reduce energy usage.

    6. **Energy-Specific Metrics and Best Practices**:
    - Suggest best practices and coding patterns for energy-efficient code, particularly focusing on areas where the current code deviates from these principles.
    - Point out potential areas where energy could be saved, such as reducing CPU-bound tasks, optimizing memory usage, or minimizing I/O operations.

    Here is the original code snippet:
    ```
    #include <algorithm>
#include <stdio.h>
#include <cmath>
#include <stdlib.h>
#include <immintrin.h>
#include <array>

constexpr double PI(3.141592653589793);
constexpr double SOLAR_MASS ( 4 * PI * PI );
constexpr double DAYS_PER_YEAR(365.24);

struct body {
  double x[3], fill, v[3], mass;
  constexpr body(double x0, double x1, double x2, double v0, double v1, double v2,  double Mass):
    x{x0,x1,x2}, fill(0), v{v0,v1,v2}, mass(Mass) {}
};

class N_Body_System
{
  static std::array<body,5> bodies;

  void offset_momentum()
  {
    unsigned int k;
    for(auto &body: bodies)
      for(k = 0; k < 3; ++k)
        bodies[0].v[k] -= body.v[k] * body.mass / SOLAR_MASS;
  }

public:
  N_Body_System()
  {
    offset_momentum();
  }
  void advance(double dt)
  {
    constexpr unsigned int N = ((bodies.size() - 1) * bodies.size()) / 2;

    static double r[N][4];
    static double mag[N];

    unsigned int i, m;
    __m128d dx[3], dsquared, distance, dmag;

    i=0;
    for(auto bi(bodies.begin()); bi!=bodies.end(); ++bi)
      {
        auto bj(bi);
        for(++bj; bj!=bodies.end(); ++bj, ++i)
          for (m=0; m<3; ++m)
            r[i][m] = bi->x[m] - bj->x[m];
      }

    for (i=0; i<N; i+=2)
      {
        for (m=0; m<3; ++m)
          {
            dx[m] = _mm_loadl_pd(dx[m], &r[i][m]);
            dx[m] = _mm_loadh_pd(dx[m], &r[i+1][m]);
          }

        dsquared = dx[0] * dx[0] + dx[1] * dx[1] + dx[2] * dx[2];
        distance = _mm_cvtps_pd(_mm_rsqrt_ps(_mm_cvtpd_ps(dsquared)));

        for (m=0; m<2; ++m)
          distance = distance * _mm_set1_pd(1.5)
            - ((_mm_set1_pd(0.5) * dsquared) * distance)
            * (distance * distance);

        dmag = _mm_set1_pd(dt) / (dsquared) * distance;
        _mm_store_pd(&mag[i], dmag);
      }

    i=0;
    for(auto bi(bodies.begin()); bi!=bodies.end(); ++bi)
      {
        auto bj(bi);
        for(++bj; bj!=bodies.end(); ++bj, ++i)
          for(m=0; m<3; ++m)
            {
              const double x = r[i][m] * mag[i];
              bi->v[m] -= x * bj->mass;
              bj->v[m] += x * bi->mass;
            }
      }

    for(auto &body: bodies)
      for(m=0; m<3; ++m)
        body.x[m] += dt * body.v[m];
  }

  double energy()
  {
    double e(0.0);
    for(auto bi(bodies.cbegin()); bi!=bodies.cend(); ++bi)
      {
        e += bi->mass * ( bi->v[0] * bi->v[0]
                          + bi->v[1] * bi->v[1]
                          + bi->v[2] * bi->v[2] ) / 2.;

        auto bj(bi);
        for(++bj; bj!=bodies.end(); ++bj)
          {
            double distance = 0;
            for(auto k=0; k<3; ++k)
            {
              const double dx = bi->x[k] - bj->x[k];
              distance += dx * dx;
            }

            e -= (bi->mass * bj->mass) / std::sqrt(distance);
          }
      }
    return e;
  }
};


std::array<body,5> N_Body_System::bodies{{
    /* sun */
    body(0., 0., 0. ,
         0., 0., 0. ,
         SOLAR_MASS),
    /* jupiter */
    body(4.84143144246472090e+00,
         -1.16032004402742839e+00,
         -1.03622044471123109e-01 ,
         1.66007664274403694e-03 * DAYS_PER_YEAR,
         7.69901118419740425e-03 * DAYS_PER_YEAR,
         -6.90460016972063023e-05 * DAYS_PER_YEAR ,
         9.54791938424326609e-04 * SOLAR_MASS
         ),
    /* saturn */
    body(8.34336671824457987e+00,
         4.12479856412430479e+00,
         -4.03523417114321381e-01 ,
         -2.76742510726862411e-03 * DAYS_PER_YEAR,
         4.99852801234917238e-03 * DAYS_PER_YEAR,
         2.30417297573763929e-05 * DAYS_PER_YEAR ,
         2.85885980666130812e-04 * SOLAR_MASS
         ),
    /* uranus */
    body(1.28943695621391310e+01,
         -1.51111514016986312e+01,
         -2.23307578892655734e-01 ,
         2.96460137564761618e-03 * DAYS_PER_YEAR,
         2.37847173959480950e-03 * DAYS_PER_YEAR,
         -2.96589568540237556e-05 * DAYS_PER_YEAR ,
         4.36624404335156298e-05 * SOLAR_MASS
         ),
    /* neptune */
    body(1.53796971148509165e+01,
         -2.59193146099879641e+01,
         1.79258772950371181e-01 ,
         2.68067772490389322e-03 * DAYS_PER_YEAR,
         1.62824170038242295e-03 * DAYS_PER_YEAR,
         -9.51592254519715870e-05 * DAYS_PER_YEAR ,
         5.15138902046611451e-05 * SOLAR_MASS
         )
  }};

int main(int , char** argv)
{
  int i, n = atoi(argv[1]);
  N_Body_System system;

  printf("%.9f\n", system.energy());
  for (i = 0; i < n; ++i)
    system.advance(0.01);
  printf("%.9f\n", system.energy());

  return 0;
}
    ```
    Average energy usage: 1161.699
    Average run time: 21154.26

    Here is the best code snippets(the lowest energy usage):
    ```
    #include <algorithm>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <omp.h>
#include <vector>
#include <immintrin.h>
#include <array>

constexpr double PI(3.141592653589793);
constexpr double SOLAR_MASS(4 * PI * PI);
constexpr double DAYS_PER_YEAR(365.24);

struct Body {
    double x[3], v[3], mass;
    constexpr Body(double x0, double x1, double x2, double v0, double v1, double v2, double Mass)
        : x{x0, x1, x2}, v{v0, v1, v2}, mass(Mass) {}
};

class NBodySystem {
    std::vector<Body> bodies;

    void offset_momentum() {
        double p[3] = {0, 0, 0};
        #pragma omp parallel for reduction(+:p[0], p[1], p[2])
        for (auto &body : bodies) {
            for (int i = 0; i < 3; ++i)
                p[i] += body.v[i] * body.mass;
        }
        for (int i = 0; i < 3; ++i)
            bodies[0].v[i] -= p[i] / SOLAR_MASS;
    }

public:
    NBodySystem() : bodies({
        Body(0, 0, 0, 0, 0, 0, SOLAR_MASS),
        Body(4.84143144246472090e+00, -1.16032004402742839e+00, -1.03622044471123109e-01,
             1.66007664274403694e-03 * DAYS_PER_YEAR, 7.69901118419740425e-03 * DAYS_PER_YEAR,
             -6.90460016972063023e-05 * DAYS_PER_YEAR, 9.54791938424326609e-04 * SOLAR_MASS),
        Body(8.34336671824457987e+00, 4.12479856412430479e+00, -4.03523417114321381e-01,
             -2.76742510726862411e-03 * DAYS_PER_YEAR, 4.99852801234917238e-03 * DAYS_PER_YEAR,
             2.30417297573763929e-05 * DAYS_PER_YEAR, 2.85885980666130812e-04 * SOLAR_MASS),
        Body(1.28943695621391310e+01, -1.51111514016986312e+01, -2.23307578892655734e-01,
             2.96460137564761618e-03 * DAYS_PER_YEAR, 2.37847173959480950e-03 * DAYS_PER_YEAR,
             -2.96589568540237556e-05 * DAYS_PER_YEAR, 4.36624404335156298e-05 * SOLAR_MASS),
        Body(1.53796971148509165e+01, -2.59193146099879641e+01, 1.79258772950371181e-01,
             2.68067772490389322e-03 * DAYS_PER_YEAR, 1.62824170038242295e-03 * DAYS_PER_YEAR,
             -9.51592254519715870e-05 * DAYS_PER_YEAR, 5.15138902046611451e-05 * SOLAR_MASS)
        }) {
        offset_momentum();
    }

    void advance(double dt) {
        size_t n = bodies.size();
        #pragma omp parallel for schedule(dynamic)
        for (size_t i = 0; i < n; ++i) {
            double r[3];
            for (size_t j = i + 1; j < n; ++j) {
                for (int m = 0; m < 3; ++m)
                    r[m] = bodies[i].x[m] - bodies[j].x[m];

                double dsquared = r[0] * r[0] + r[1] * r[1] + r[2] * r[2];
                double distance = std::sqrt(dsquared);
                double mag = dt / (dsquared * distance);
                
                double force[3];
                for (int m = 0; m < 3; ++m) {
                    force[m] = r[m] * mag;
                    #pragma omp atomic
                    bodies[i].v[m] -= force[m] * bodies[j].mass;
                    #pragma omp atomic
                    bodies[j].v[m] += force[m] * bodies[i].mass;
                }
            }
        }

        #pragma omp parallel for
        for (size_t i = 0; i < n; ++i) {
            for (int m = 0; m < 3; ++m)
                bodies[i].x[m] += dt * bodies[i].v[m];
        }
    }

    double energy() const {
        double e = 0.0;
        for (auto bi = bodies.begin(); bi != bodies.end(); ++bi) {
            e += bi->mass * (bi->v[0] * bi->v[0] + bi->v[1] * bi->v[1] + bi->v[2] * bi->v[2]) / 2.0;
            for (auto bj = bi + 1; bj != bodies.end(); ++bj) {
                double distance = 0;
                for (int k = 0; k < 3; ++k) {
                    double dx = bi->x[k] - bj->x[k];
                    distance += dx * dx;
                }
                e -= (bi->mass * bj->mass) / std::sqrt(distance);
            }
        }
        return e;
    }
};

int main(int argc, char **argv) {
    int n = atoi(argv[1]);
    NBodySystem system;
    std::printf("%.9f\n", system.energy());
    for (int i = 0; i < n; ++i)
        system.advance(0.01);
    std::printf("%.9f\n", system.energy());
    return 0;
}
    ```
    Average energy usage: -50970.707
    Average run time: 26807.18

    Here is the current code snippiets that you are tasked to optimize:
    ```
    #include <algorithm>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <omp.h>
#include <vector>
#include <immintrin.h>
#include <array>

constexpr double PI(3.141592653589793);
constexpr double SOLAR_MASS(4 * PI * PI);
constexpr double DAYS_PER_YEAR(365.24);

struct Body {
    double x[3], v[3], mass;
    constexpr Body(double x0, double x1, double x2, double v0, double v1, double v2, double Mass)
        : x{x0, x1, x2}, v{v0, v1, v2}, mass(Mass) {}
};

class NBodySystem {
    std::vector<Body> bodies;

    void offset_momentum() {
        double p[3] = {0, 0, 0};
        #pragma omp parallel for reduction(+:p[0], p[1], p[2])
        for (auto &body : bodies) {
            for (int i = 0; i < 3; ++i)
                p[i] += body.v[i] * body.mass;
        }
        for (int i = 0; i < 3; ++i)
            bodies[0].v[i] -= p[i] / SOLAR_MASS;
    }

public:
    NBodySystem() : bodies({
        Body(0, 0, 0, 0, 0, 0, SOLAR_MASS),
        Body(4.84143144246472090e+00, -1.16032004402742839e+00, -1.03622044471123109e-01,
             1.66007664274403694e-03 * DAYS_PER_YEAR, 7.69901118419740425e-03 * DAYS_PER_YEAR,
             -6.90460016972063023e-05 * DAYS_PER_YEAR, 9.54791938424326609e-04 * SOLAR_MASS),
        Body(8.34336671824457987e+00, 4.12479856412430479e+00, -4.03523417114321381e-01,
             -2.76742510726862411e-03 * DAYS_PER_YEAR, 4.99852801234917238e-03 * DAYS_PER_YEAR,
             2.30417297573763929e-05 * DAYS_PER_YEAR, 2.85885980666130812e-04 * SOLAR_MASS),
        Body(1.28943695621391310e+01, -1.51111514016986312e+01, -2.23307578892655734e-01,
             2.96460137564761618e-03 * DAYS_PER_YEAR, 2.37847173959480950e-03 * DAYS_PER_YEAR,
             -2.96589568540237556e-05 * DAYS_PER_YEAR, 4.36624404335156298e-05 * SOLAR_MASS),
        Body(1.53796971148509165e+01, -2.59193146099879641e+01, 1.79258772950371181e-01,
             2.68067772490389322e-03 * DAYS_PER_YEAR, 1.62824170038242295e-03 * DAYS_PER_YEAR,
             -9.51592254519715870e-05 * DAYS_PER_YEAR, 5.15138902046611451e-05 * SOLAR_MASS)
        }) {
        offset_momentum();
    }

    void advance(double dt) {
        size_t n = bodies.size();
        #pragma omp parallel for schedule(dynamic)
        for (size_t i = 0; i < n; ++i) {
            double r[3];
            for (size_t j = i + 1; j < n; ++j) {
                for (int m = 0; m < 3; ++m)
                    r[m] = bodies[i].x[m] - bodies[j].x[m];

                double dsquared = r[0] * r[0] + r[1] * r[1] + r[2] * r[2];
                double distance = std::sqrt(dsquared);
                double mag = dt / (dsquared * distance);
                
                double force[3];
                for (int m = 0; m < 3; ++m) {
                    force[m] = r[m] * mag;
                    #pragma omp atomic
                    bodies[i].v[m] -= force[m] * bodies[j].mass;
                    #pragma omp atomic
                    bodies[j].v[m] += force[m] * bodies[i].mass;
                }
            }
        }

        #pragma omp parallel for
        for (size_t i = 0; i < n; ++i) {
            for (int m = 0; m < 3; ++m)
                bodies[i].x[m] += dt * bodies[i].v[m];
        }
    }

    double energy() const {
        double e = 0.0;
        for (auto bi = bodies.begin(); bi != bodies.end(); ++bi) {
            e += bi->mass * (bi->v[0] * bi->v[0] + bi->v[1] * bi->v[1] + bi->v[2] * bi->v[2]) / 2.0;
            for (auto bj = bi + 1; bj != bodies.end(); ++bj) {
                double distance = 0;
                for (int k = 0; k < 3; ++k) {
                    double dx = bi->x[k] - bj->x[k];
                    distance += dx * dx;
                }
                e -= (bi->mass * bj->mass) / std::sqrt(distance);
            }
        }
        return e;
    }
};

int main(int argc, char **argv) {
    int n = atoi(argv[1]);
    NBodySystem system;
    std::printf("%.9f\n", system.energy());
    for (int i = 0; i < n; ++i)
        system.advance(0.01);
    std::printf("%.9f\n", system.energy());
    return 0;
}
    ```
    Average energy usage: -50970.707
    Average run time: 26807.18

    Please respond in natural language (English) with actionable suggestions for improving the code's performance in terms of energy usage. Provide only the best code with the lowest energy usage.
    